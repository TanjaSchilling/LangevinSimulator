<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TensorUtils: TensorUtils::TensorBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TensorUtils
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>TensorUtils</b></li><li class="navelem"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTensorUtils_1_1TensorBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TensorUtils::TensorBase&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This is the main class of this project. It inherits from std::vector&lt;T&gt; and adds methods to make it a tensor.  
 <a href="classTensorUtils_1_1TensorBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TensorBase_8hpp_source.html">TensorBase.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TensorUtils::TensorBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classTensorUtils_1_1TensorBase__inherit__graph.png" border="0" usemap="#aTensorUtils_1_1TensorBase_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aTensorUtils_1_1TensorBase_3_01T_01_4_inherit__map" id="aTensorUtils_1_1TensorBase_3_01T_01_4_inherit__map">
<area shape="rect" title="This is the main class of this project. It inherits from std::vector&lt;T&gt; and adds methods to make it a..." alt="" coords="98,80,295,107"/>
<area shape="rect" href="classTensorUtils_1_1TensorDerived.html" title="This class defines a tensor with fixed rank N=0,1,... and inherits from TensorBase...." alt="" coords="5,155,185,196"/>
<area shape="rect" href="classTensorUtils_1_1TensorDerived_3_01T_00-1_01_4.html" title="This class specialization defines a tensor with mutable rank and inherits from TensorBase." alt="" coords="209,155,389,196"/>
<area shape="rect" title=" " alt="" coords="139,5,255,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for TensorUtils::TensorBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classTensorUtils_1_1TensorBase__coll__graph.png" border="0" usemap="#aTensorUtils_1_1TensorBase_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aTensorUtils_1_1TensorBase_3_01T_01_4_coll__map" id="aTensorUtils_1_1TensorBase_3_01T_01_4_coll__map">
<area shape="rect" title="This is the main class of this project. It inherits from std::vector&lt;T&gt; and adds methods to make it a..." alt="" coords="5,80,203,107"/>
<area shape="rect" title=" " alt="" coords="46,5,162,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e49a661d7197fb89e1b44ed68196abf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a9e49a661d7197fb89e1b44ed68196abf">TensorBase</a> ()</td></tr>
<tr class="separator:a9e49a661d7197fb89e1b44ed68196abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43e5968e4ea0fa003eecc7613b0a59d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#ac43e5968e4ea0fa003eecc7613b0a59d">TensorBase</a> (const std::vector&lt; size_t &gt; &amp;<a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a>)</td></tr>
<tr class="separator:ac43e5968e4ea0fa003eecc7613b0a59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d2d2d12631a4a74b983ea126b304b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#ad8d2d2d12631a4a74b983ea126b304b9">TensorBase</a> (const std::vector&lt; size_t &gt; &amp;<a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a>, const T &amp;val)</td></tr>
<tr class="separator:ad8d2d2d12631a4a74b983ea126b304b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab801d73f9db5666d14bf756534580dbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#ab801d73f9db5666d14bf756534580dbd">alloc</a> (const std::vector&lt; size_t &gt; &amp;<a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a>)</td></tr>
<tr class="separator:ab801d73f9db5666d14bf756534580dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f1d1e80532dfeeffae817b1104e4d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#aa6f1d1e80532dfeeffae817b1104e4d0">alloc</a> (const std::vector&lt; size_t &gt; &amp;<a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a>, const T &amp;val)</td></tr>
<tr class="separator:aa6f1d1e80532dfeeffae817b1104e4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712e515b125851e237042459f350e0ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a712e515b125851e237042459f350e0ab">init</a> (const T &amp;val)</td></tr>
<tr class="separator:a712e515b125851e237042459f350e0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0349fb0faae387b46f42a8ab4f4373a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">arange</a> (T val=0)</td></tr>
<tr class="separator:ab0349fb0faae387b46f42a8ab4f4373a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6ab3cbf7851390aaeefa05a8ed0c24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a9d6ab3cbf7851390aaeefa05a8ed0c24">clear</a> ()</td></tr>
<tr class="separator:a9d6ab3cbf7851390aaeefa05a8ed0c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af745ceedbb4628bae6cc467b250f67b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#af745ceedbb4628bae6cc467b250f67b0">print</a> ()</td></tr>
<tr class="separator:af745ceedbb4628bae6cc467b250f67b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4589420d9febe0a07051d9358567c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a5e4589420d9febe0a07051d9358567c5">read</a> (std::string path)</td></tr>
<tr class="separator:a5e4589420d9febe0a07051d9358567c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a701c44e4f0a077a7c2c45d43d88571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a8a701c44e4f0a077a7c2c45d43d88571">write</a> (std::string oname, std::string folder)</td></tr>
<tr class="separator:a8a701c44e4f0a077a7c2c45d43d88571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae877870922e2b9e60fc866a855da42be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#ae877870922e2b9e60fc866a855da42be">write</a> (std::string oname, std::string folder, int precision)</td></tr>
<tr class="separator:ae877870922e2b9e60fc866a855da42be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b60930e74e3e4780e4f06c4e30f5de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#ab6b60930e74e3e4780e4f06c4e30f5de">transpose</a> (const std::vector&lt; unsigned &gt; &amp;axes)</td></tr>
<tr class="separator:ab6b60930e74e3e4780e4f06c4e30f5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3728b9a49d84b535815d4b7335132f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a3728b9a49d84b535815d4b7335132f29">slice</a> (const std::vector&lt; size_t &gt; &amp;idx_at)</td></tr>
<tr class="separator:a3728b9a49d84b535815d4b7335132f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474772c9878ca9498b7caf39204f8454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a474772c9878ca9498b7caf39204f8454">reshape</a> (const std::vector&lt; size_t &gt; &amp;<a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a>)</td></tr>
<tr class="separator:a474772c9878ca9498b7caf39204f8454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bf80a09ab04dba6dad6f37f979d772"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:af8bf80a09ab04dba6dad6f37f979d772"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#af8bf80a09ab04dba6dad6f37f979d772">dot</a> (<a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs, const std::vector&lt; int &gt; &amp;idx_lhs, const std::vector&lt; int &gt; &amp;idx_rhs, const std::vector&lt; size_t &gt; &amp;idx_at={})</td></tr>
<tr class="separator:af8bf80a09ab04dba6dad6f37f979d772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea73eab094bc56b73271bb6a6f11d7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#aaea73eab094bc56b73271bb6a6f11d7c">contract</a> (const std::vector&lt; int &gt; &amp;idx_lhs, const std::vector&lt; size_t &gt; &amp;idx_at={})</td></tr>
<tr class="separator:aaea73eab094bc56b73271bb6a6f11d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eed73b66bc0280587bf7b1b06ab3e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a2eed73b66bc0280587bf7b1b06ab3e1a">operator=</a> (const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a2eed73b66bc0280587bf7b1b06ab3e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09696fdcb5d7cb23e213418097c6adf1"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a09696fdcb5d7cb23e213418097c6adf1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a09696fdcb5d7cb23e213418097c6adf1">operator=</a> (const <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a09696fdcb5d7cb23e213418097c6adf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a28b9b40eacef639302f9bccb03b6e"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a10a28b9b40eacef639302f9bccb03b6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a10a28b9b40eacef639302f9bccb03b6e">operator+=</a> (const <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a10a28b9b40eacef639302f9bccb03b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb39881c875044087940545f62f85f8"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:aadb39881c875044087940545f62f85f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#aadb39881c875044087940545f62f85f8">operator+</a> (const <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:aadb39881c875044087940545f62f85f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5ff63bddf658da9dae9ce45d57766d"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a5a5ff63bddf658da9dae9ce45d57766d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a5a5ff63bddf658da9dae9ce45d57766d">operator-=</a> (const <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a5a5ff63bddf658da9dae9ce45d57766d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670ea0ff13c250e1712c8ee5dd4edadf"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a670ea0ff13c250e1712c8ee5dd4edadf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a670ea0ff13c250e1712c8ee5dd4edadf">operator-</a> (const <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a670ea0ff13c250e1712c8ee5dd4edadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9068061b6ccbd3087fee92ac889e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#ade9068061b6ccbd3087fee92ac889e57">operator*=</a> (const T &amp;rhs)</td></tr>
<tr class="separator:ade9068061b6ccbd3087fee92ac889e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15e6c2ac11c6c84b9ae17f7628b3ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#ab15e6c2ac11c6c84b9ae17f7628b3ce3">operator*</a> (const T &amp;rhs)</td></tr>
<tr class="separator:ab15e6c2ac11c6c84b9ae17f7628b3ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd9a48d430299ab6a86dee248490869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a6dd9a48d430299ab6a86dee248490869">operator/=</a> (const T &amp;rhs)</td></tr>
<tr class="separator:a6dd9a48d430299ab6a86dee248490869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb96bbabd1805fac487bfb3ecef075d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#aeeb96bbabd1805fac487bfb3ecef075d">operator/</a> (const T &amp;rhs)</td></tr>
<tr class="separator:aeeb96bbabd1805fac487bfb3ecef075d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae440fc1ecba5d939aa97f5c06964b712"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:ae440fc1ecba5d939aa97f5c06964b712"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#ae440fc1ecba5d939aa97f5c06964b712">operator&lt;&lt;</a> (T2 &amp;rhs)</td></tr>
<tr class="separator:ae440fc1ecba5d939aa97f5c06964b712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7965f2a99720460c6d7193b84145c8f"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:af7965f2a99720460c6d7193b84145c8f"><td class="memTemplItemLeft" align="right" valign="top">T2 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#af7965f2a99720460c6d7193b84145c8f">operator&gt;&gt;</a> (T2 &amp;rhs)</td></tr>
<tr class="separator:af7965f2a99720460c6d7193b84145c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a7ab2f7843c6713587589667502b9c"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a67a7ab2f7843c6713587589667502b9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a67a7ab2f7843c6713587589667502b9c">assign</a> (<a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={}, const std::vector&lt; size_t &gt; &amp;at_rhs={})</td></tr>
<tr class="separator:a67a7ab2f7843c6713587589667502b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56693273b5868d42bdd46ed83e9f97fc"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a56693273b5868d42bdd46ed83e9f97fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a56693273b5868d42bdd46ed83e9f97fc">add</a> (<a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={}, const std::vector&lt; size_t &gt; &amp;at_rhs={})</td></tr>
<tr class="separator:a56693273b5868d42bdd46ed83e9f97fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf02bbd67b6ae85949f261e149076028"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:abf02bbd67b6ae85949f261e149076028"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#abf02bbd67b6ae85949f261e149076028">substract</a> (<a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={}, const std::vector&lt; size_t &gt; &amp;at_rhs={})</td></tr>
<tr class="separator:abf02bbd67b6ae85949f261e149076028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3534521430b09a31d662a714cde93614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a3534521430b09a31d662a714cde93614">multiply</a> (const T &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={})</td></tr>
<tr class="separator:a3534521430b09a31d662a714cde93614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85201d77bda10d8111c85115ab16ed9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a85201d77bda10d8111c85115ab16ed9b">divide</a> (const T &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={})</td></tr>
<tr class="separator:a85201d77bda10d8111c85115ab16ed9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9969230537671dbb1390c535926da127"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a9969230537671dbb1390c535926da127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a9969230537671dbb1390c535926da127">plus</a> (<a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={}, const std::vector&lt; size_t &gt; &amp;at_rhs={})</td></tr>
<tr class="separator:a9969230537671dbb1390c535926da127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97bc4faf34b9d96682cb2089e8867c3"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:ac97bc4faf34b9d96682cb2089e8867c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#ac97bc4faf34b9d96682cb2089e8867c3">minus</a> (<a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={}, const std::vector&lt; size_t &gt; &amp;at_rhs={})</td></tr>
<tr class="separator:ac97bc4faf34b9d96682cb2089e8867c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a7d5fdbd5851469350127a3d2e7213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a73a7d5fdbd5851469350127a3d2e7213">product</a> (const T &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={})</td></tr>
<tr class="separator:a73a7d5fdbd5851469350127a3d2e7213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e417f700ec1f412fd004ea510a5e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a91e417f700ec1f412fd004ea510a5e3a">quotient</a> (const T &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={})</td></tr>
<tr class="separator:a91e417f700ec1f412fd004ea510a5e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9f812fee355d67df2e7f5d2b409299"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()</a> (const std::vector&lt; size_t &gt; &amp;indices)</td></tr>
<tr class="separator:a5b9f812fee355d67df2e7f5d2b409299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9e97dc889fb2d6833c1514004c48f6"><td class="memItemLeft" align="right" valign="top"><a id="adc9e97dc889fb2d6833c1514004c48f6" name="adc9e97dc889fb2d6833c1514004c48f6"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const std::vector&lt; size_t * &gt; &amp;indices)</td></tr>
<tr class="memdesc:adc9e97dc889fb2d6833c1514004c48f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()(const std::vector&lt;size_t&gt; &amp;)</a>. <br /></td></tr>
<tr class="separator:adc9e97dc889fb2d6833c1514004c48f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b40657e93e66d354777611b78189c8b"><td class="memItemLeft" align="right" valign="top"><a id="a2b40657e93e66d354777611b78189c8b" name="a2b40657e93e66d354777611b78189c8b"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> ()</td></tr>
<tr class="memdesc:a2b40657e93e66d354777611b78189c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()(const std::vector&lt;size_t&gt; &amp;)</a>. <br /></td></tr>
<tr class="separator:a2b40657e93e66d354777611b78189c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae435df6450c82095556a170560816a7b"><td class="memItemLeft" align="right" valign="top"><a id="ae435df6450c82095556a170560816a7b" name="ae435df6450c82095556a170560816a7b"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_t n0)</td></tr>
<tr class="memdesc:ae435df6450c82095556a170560816a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()(const std::vector&lt;size_t&gt; &amp;)</a>. <br /></td></tr>
<tr class="separator:ae435df6450c82095556a170560816a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0add2aac67c373e9fee3fcf8c317086"><td class="memItemLeft" align="right" valign="top"><a id="ac0add2aac67c373e9fee3fcf8c317086" name="ac0add2aac67c373e9fee3fcf8c317086"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_t n0, size_t n1)</td></tr>
<tr class="memdesc:ac0add2aac67c373e9fee3fcf8c317086"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()(const std::vector&lt;size_t&gt; &amp;)</a>. <br /></td></tr>
<tr class="separator:ac0add2aac67c373e9fee3fcf8c317086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689020f2b0f593beb861a1c093b69afa"><td class="memItemLeft" align="right" valign="top"><a id="a689020f2b0f593beb861a1c093b69afa" name="a689020f2b0f593beb861a1c093b69afa"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_t n0, size_t n1, size_t n2)</td></tr>
<tr class="memdesc:a689020f2b0f593beb861a1c093b69afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()(const std::vector&lt;size_t&gt; &amp;)</a>. <br /></td></tr>
<tr class="separator:a689020f2b0f593beb861a1c093b69afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a10d6b182b5ced1f8faa9307595e22"><td class="memItemLeft" align="right" valign="top"><a id="a55a10d6b182b5ced1f8faa9307595e22" name="a55a10d6b182b5ced1f8faa9307595e22"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_t n0, size_t n1, size_t n2, size_t n3)</td></tr>
<tr class="memdesc:a55a10d6b182b5ced1f8faa9307595e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()(const std::vector&lt;size_t&gt; &amp;)</a>. <br /></td></tr>
<tr class="separator:a55a10d6b182b5ced1f8faa9307595e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1fdb8705c460a6e1957f5d64dd3788"><td class="memItemLeft" align="right" valign="top"><a id="ade1fdb8705c460a6e1957f5d64dd3788" name="ade1fdb8705c460a6e1957f5d64dd3788"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_t n0, size_t n1, size_t n2, size_t n3, size_t n4)</td></tr>
<tr class="memdesc:ade1fdb8705c460a6e1957f5d64dd3788"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()(const std::vector&lt;size_t&gt; &amp;)</a>. <br /></td></tr>
<tr class="separator:ade1fdb8705c460a6e1957f5d64dd3788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94078534d92c5e1cad76df3162b2423"><td class="memItemLeft" align="right" valign="top"><a id="ab94078534d92c5e1cad76df3162b2423" name="ab94078534d92c5e1cad76df3162b2423"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_t n0, size_t n1, size_t n2, size_t n3, size_t n4, size_t n5)</td></tr>
<tr class="memdesc:ab94078534d92c5e1cad76df3162b2423"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()(const std::vector&lt;size_t&gt; &amp;)</a>. <br /></td></tr>
<tr class="separator:ab94078534d92c5e1cad76df3162b2423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b7f0ff3c99e33f78468da267797330"><td class="memItemLeft" align="right" valign="top"><a id="a92b7f0ff3c99e33f78468da267797330" name="a92b7f0ff3c99e33f78468da267797330"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_t n0, size_t n1, size_t n2, size_t n3, size_t n4, size_t n5, size_t n6)</td></tr>
<tr class="memdesc:a92b7f0ff3c99e33f78468da267797330"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()(const std::vector&lt;size_t&gt; &amp;)</a>. <br /></td></tr>
<tr class="separator:a92b7f0ff3c99e33f78468da267797330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73280ec2ab23f1f52776ff47628a372"><td class="memItemLeft" align="right" valign="top"><a id="ad73280ec2ab23f1f52776ff47628a372" name="ad73280ec2ab23f1f52776ff47628a372"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (size_t n0, size_t n1, size_t n2, size_t n3, size_t n4, size_t n5, size_t n6, size_t n7)</td></tr>
<tr class="memdesc:ad73280ec2ab23f1f52776ff47628a372"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5b9f812fee355d67df2e7f5d2b409299">operator()(const std::vector&lt;size_t&gt; &amp;)</a>. <br /></td></tr>
<tr class="separator:ad73280ec2ab23f1f52776ff47628a372"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:adb62602f86f3266f2344c69b15b1fe28"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a></td></tr>
<tr class="separator:adb62602f86f3266f2344c69b15b1fe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cdd295089539c15f9b09726a9371a0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a10cdd295089539c15f9b09726a9371a0">incr</a></td></tr>
<tr class="separator:a10cdd295089539c15f9b09726a9371a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a309bb54047ba27387bb12b5a95e31e9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorUtils_1_1TensorBase.html#a309bb54047ba27387bb12b5a95e31e9e">operator*</a> (const T &amp;lhs, <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; rhs)</td></tr>
<tr class="separator:a309bb54047ba27387bb12b5a95e31e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class TensorUtils::TensorBase&lt; T &gt;</div><p >This is the main class of this project. It inherits from std::vector&lt;T&gt; and adds methods to make it a tensor. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9e49a661d7197fb89e1b44ed68196abf" name="a9e49a661d7197fb89e1b44ed68196abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e49a661d7197fb89e1b44ed68196abf">&#9670;&nbsp;</a></span>TensorBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::TensorBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Empty constructor. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> foo;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorDerived_html"><div class="ttname"><a href="classTensorUtils_1_1TensorDerived.html">TensorUtils::TensorDerived</a></div><div class="ttdoc">This class defines a tensor with fixed rank N=0,1,... and inherits from TensorBase....</div><div class="ttdef"><b>Definition:</b> TensorDerived.hpp:65</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac43e5968e4ea0fa003eecc7613b0a59d" name="ac43e5968e4ea0fa003eecc7613b0a59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43e5968e4ea0fa003eecc7613b0a59d">&#9670;&nbsp;</a></span>TensorBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::TensorBase </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructor. Calls <a class="el" href="classTensorUtils_1_1TensorBase.html#ab801d73f9db5666d14bf756534580dbd">alloc(const std::vector&lt;size_t&gt; &amp;)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>Specifies the number of indices and their ranges.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// TensorUtils::tensor&lt;double&gt; foo({}); // invalid syntax: ambiguity with copy and move constructor!</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> foo({2,3,5,7});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad8d2d2d12631a4a74b983ea126b304b9" name="ad8d2d2d12631a4a74b983ea126b304b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d2d2d12631a4a74b983ea126b304b9">&#9670;&nbsp;</a></span>TensorBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::TensorBase </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructor. Calls <a class="el" href="classTensorUtils_1_1TensorBase.html#aa6f1d1e80532dfeeffae817b1104e4d0">alloc(const std::vector&lt;size_t&gt; &amp;, const T&amp;)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>Specifies the number of indices and their ranges. </td></tr>
    <tr><td class="paramname">val</td><td>All components are initialized with this value.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> foo({}, 1.0); <span class="comment">// scalar</span></div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar({2,3,5,7}, 1.0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a56693273b5868d42bdd46ed83e9f97fc" name="a56693273b5868d42bdd46ed83e9f97fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56693273b5868d42bdd46ed83e9f97fc">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_lhs</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_rhs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a sub-tensor of <code>rhs</code> to a sub-tensor of this tensor. Number of components must match, else <a class="el" href="classTensorUtils_1_1ErrorHandler_1_1ShapeMismatch.html">ErrorHandler::ShapeMismatch</a> is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
    <tr><td class="paramname">at_lhs</td><td>Indices specifying the sub-tensor of the first operand. </td></tr>
    <tr><td class="paramname">at_rhs</td><td>Indices specifying the sub-tensor of the second operand.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar({2*3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#a56693273b5868d42bdd46ed83e9f97fc">add</a>(bar, {1,2}, {5});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_a56693273b5868d42bdd46ed83e9f97fc"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#a56693273b5868d42bdd46ed83e9f97fc">TensorUtils::TensorBase::add</a></div><div class="ttdeci">TensorBase&lt; T &gt; &amp; add(TensorBase&lt; T2 &gt; &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={}, const std::vector&lt; size_t &gt; &amp;at_rhs={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab801d73f9db5666d14bf756534580dbd" name="ab801d73f9db5666d14bf756534580dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab801d73f9db5666d14bf756534580dbd">&#9670;&nbsp;</a></span>alloc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::alloc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocates the necessary memory and initializes <a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a> and <a class="el" href="classTensorUtils_1_1TensorBase.html#a10cdd295089539c15f9b09726a9371a0">incr</a> accordingly. If an empty shape is received, the tensor is a scalar with exactly one component. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>Used to initialize <a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a>.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> foo;</div>
<div class="line"> </div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorDerived.html#aebad84a5c4d2433e48b8c8f77603d6df">alloc</a>({2,3,5,7});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorDerived_html_aebad84a5c4d2433e48b8c8f77603d6df"><div class="ttname"><a href="classTensorUtils_1_1TensorDerived.html#aebad84a5c4d2433e48b8c8f77603d6df">TensorUtils::TensorDerived::alloc</a></div><div class="ttdeci">void alloc(const std::vector&lt; size_t &gt; shape)</div><div class="ttdoc">Inherits from TensorBase and throws ErrorHandler::RankMismatch if shape.size()!=N.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa6f1d1e80532dfeeffae817b1104e4d0" name="aa6f1d1e80532dfeeffae817b1104e4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f1d1e80532dfeeffae817b1104e4d0">&#9670;&nbsp;</a></span>alloc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::alloc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate memory and initialize all components. Calls <a class="el" href="classTensorUtils_1_1TensorBase.html#ab801d73f9db5666d14bf756534580dbd">alloc(const std::vector&lt;size_t&gt; &amp;shape)</a> and <a class="el" href="classTensorUtils_1_1TensorBase.html#a712e515b125851e237042459f350e0ab">init(const T&amp; val)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>Used to initialize <a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a>. </td></tr>
    <tr><td class="paramname">val</td><td>All components are initialized with this value.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> foo;</div>
<div class="line"> </div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorDerived.html#aebad84a5c4d2433e48b8c8f77603d6df">alloc</a>({2,3,5,7}, 1.0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab0349fb0faae387b46f42a8ab4f4373a" name="ab0349fb0faae387b46f42a8ab4f4373a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0349fb0faae387b46f42a8ab4f4373a">&#9670;&nbsp;</a></span>arange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::arange </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize all components with lexicographical enumeration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value of first component.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> my_tensor({10,10});</div>
<div class="line"> </div>
<div class="line">    my_tensor.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">arange</a>(1); <span class="comment">// same as the following</span></div>
<div class="line"> </div>
<div class="line">    my_tensor(0,0)=1;</div>
<div class="line">    my_tensor(0,1)=2;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    my_tensor(9,9)=100;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_ab0349fb0faae387b46f42a8ab4f4373a"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">TensorUtils::TensorBase::arange</a></div><div class="ttdeci">void arange(T val=0)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a67a7ab2f7843c6713587589667502b9c" name="a67a7ab2f7843c6713587589667502b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a7ab2f7843c6713587589667502b9c">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_lhs</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_rhs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assign a sub-tensor this tensor with a sub-tensor of <code>rhs</code>. Number of components must match, else <a class="el" href="classTensorUtils_1_1ErrorHandler_1_1ShapeMismatch.html">ErrorHandler::ShapeMismatch</a> is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
    <tr><td class="paramname">at_lhs</td><td>Indices specifying the sub-tensor of the first operand. </td></tr>
    <tr><td class="paramname">at_rhs</td><td>Indices specifying the sub-tensor of the second operand.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar({2*3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#a67a7ab2f7843c6713587589667502b9c">assign</a>(bar, {1,2}, {5});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_a67a7ab2f7843c6713587589667502b9c"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#a67a7ab2f7843c6713587589667502b9c">TensorUtils::TensorBase::assign</a></div><div class="ttdeci">TensorBase&lt; T &gt; &amp; assign(TensorBase&lt; T2 &gt; &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={}, const std::vector&lt; size_t &gt; &amp;at_rhs={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9d6ab3cbf7851390aaeefa05a8ed0c24" name="a9d6ab3cbf7851390aaeefa05a8ed0c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6ab3cbf7851390aaeefa05a8ed0c24">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clears the memory and the member variables <a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a> and <a class="el" href="classTensorUtils_1_1TensorBase.html#a10cdd295089539c15f9b09726a9371a0">incr</a>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> foo({2,3,5,7}, 1.0);</div>
<div class="line"> </div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorDerived.html#a89af3f7f701efac744dad03237f096a6">clear</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorDerived_html_a89af3f7f701efac744dad03237f096a6"><div class="ttname"><a href="classTensorUtils_1_1TensorDerived.html#a89af3f7f701efac744dad03237f096a6">TensorUtils::TensorDerived::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Inherits from TensorBase and resizes shape and incr with size N.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaea73eab094bc56b73271bb6a6f11d7c" name="aaea73eab094bc56b73271bb6a6f11d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea73eab094bc56b73271bb6a6f11d7c">&#9670;&nbsp;</a></span>contract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::contract </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx_at</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sum over specified axes and return the remaining subtensor. Indices are represented by signed integers. The parameters <code>idx_lhs</code> enumerates the indices of this tensor. Indices represented by negative integers are summed over. The order of the return value can be set as desired and is given in increasing order of the resulting indices. Optionally, it is possible to compute only a sub-tensor of the final result by setting the parameter <code>idx_at</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx_lhs</td><td>Indices of first operand represented by signed integers. </td></tr>
    <tr><td class="paramname">idx_at</td><td>Indices specifying the sub-tensor to be computed.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> X({3,3,5,5},1);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> Z;</div>
<div class="line"> </div>
<div class="line">    Z = X.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#aaea73eab094bc56b73271bb6a6f11d7c">contract</a>({-1,-2,-3,-4});   <span class="comment">// sum of all components!</span></div>
<div class="line"> </div>
<div class="line">    Z = X.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#aaea73eab094bc56b73271bb6a6f11d7c">contract</a>({1,2,-1,-1}); <span class="comment">// trace of all submatrices</span></div>
<div class="line"> </div>
<div class="line">    Z = X.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#aaea73eab094bc56b73271bb6a6f11d7c">contract</a>({2,1,-1,-1}); <span class="comment">// same but transposed</span></div>
<div class="line"> </div>
<div class="line">    Z = X.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#aaea73eab094bc56b73271bb6a6f11d7c">contract</a>({1,1,-1,-1}); <span class="comment">// main diagonal of the previous result</span></div>
<div class="line"> </div>
<div class="line">    Z = X.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#aaea73eab094bc56b73271bb6a6f11d7c">contract</a>({1,2,-1,-1}, {0,0}); <span class="comment">// trace of first submatrix</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_aaea73eab094bc56b73271bb6a6f11d7c"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#aaea73eab094bc56b73271bb6a6f11d7c">TensorUtils::TensorBase::contract</a></div><div class="ttdeci">TensorBase&lt; T &gt; contract(const std::vector&lt; int &gt; &amp;idx_lhs, const std::vector&lt; size_t &gt; &amp;idx_at={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a85201d77bda10d8111c85115ab16ed9b" name="a85201d77bda10d8111c85115ab16ed9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85201d77bda10d8111c85115ab16ed9b">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::divide </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_lhs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Divide a sub-tensor of this tensor with <code>rhs</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
    <tr><td class="paramname">at_lhs</td><td>Indices specifying the sub-tensor of the first operand.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#a85201d77bda10d8111c85115ab16ed9b">divide</a>(5, {1,2});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_a85201d77bda10d8111c85115ab16ed9b"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#a85201d77bda10d8111c85115ab16ed9b">TensorUtils::TensorBase::divide</a></div><div class="ttdeci">TensorBase&lt; T &gt; &amp; divide(const T &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af8bf80a09ab04dba6dad6f37f979d772" name="af8bf80a09ab04dba6dad6f37f979d772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bf80a09ab04dba6dad6f37f979d772">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx_at</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a generalized tensor product by value. Indices are represented by signed integers. The parameters <code>idx_lhs</code> and <code>idx_rhs</code> specify the indices for the two operands. Negative integers are summed over. Multiple occurrences of the same index performs element-wise multiplication (Hadamard product). Distinct indices perform the usual tensor product. It is possible to mix summation, element-wise multiplication and the usual tensor product as desired. The order of the return value can be set as desired and is given in increasing order of the resulting indices. Additionally, it is possible to compute only a sub-tensor of the final result by setting the parameter <code>idx_at</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
    <tr><td class="paramname">idx_lhs</td><td>Indices of first operand represented by signed intergers. </td></tr>
    <tr><td class="paramname">idx_rhs</td><td>Indices of second operand represented by signed integers. </td></tr>
    <tr><td class="paramname">idx_at</td><td>Indices specifying the sub-tensor to be computed.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> X({2,3,5,7},1);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> Y({2,3,5,7},2);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> Z;</div>
<div class="line"> </div>
<div class="line">    Z = X.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#af8bf80a09ab04dba6dad6f37f979d772">dot</a>(Y,{-1,-2,-3,-4},{-1,-2,-3,-4});   <span class="comment">// full contraction: Z is a scalar!</span></div>
<div class="line"> </div>
<div class="line">    Z = X.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#af8bf80a09ab04dba6dad6f37f979d772">dot</a>(Y,{1,2,3,4},{1,2,3,4});           <span class="comment">// Hadamard product: Z has shape {2,3,5,7}</span></div>
<div class="line"> </div>
<div class="line">    Z = X.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#af8bf80a09ab04dba6dad6f37f979d772">dot</a>(Y,{1,2,3,4},{8,7,6,5});           <span class="comment">// tensor product: Z has shape {2,3,5,7,7,5,3,2}</span></div>
<div class="line"> </div>
<div class="line">    Z = X.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#af8bf80a09ab04dba6dad6f37f979d772">dot</a>(Y,{1,2,3,4},{5,6,7,8}, {1,2,4,6}); <span class="comment">// compute sub-tensor of tensor-product</span></div>
<div class="line"> </div>
<div class="line">    X.alloc({2,3,7,7},1);</div>
<div class="line">    Y.alloc({7,5,3,11},2);</div>
<div class="line"> </div>
<div class="line">    Z = X.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#af8bf80a09ab04dba6dad6f37f979d772">dot</a>(Y,{3,2,-5,-5},{-5,4,2,1});    <span class="comment">// generalized tensor product: Z has shape {11,3,2,5}</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_af8bf80a09ab04dba6dad6f37f979d772"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#af8bf80a09ab04dba6dad6f37f979d772">TensorUtils::TensorBase::dot</a></div><div class="ttdeci">TensorBase&lt; T &gt; dot(TensorBase&lt; T2 &gt; &amp;rhs, const std::vector&lt; int &gt; &amp;idx_lhs, const std::vector&lt; int &gt; &amp;idx_rhs, const std::vector&lt; size_t &gt; &amp;idx_at={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a712e515b125851e237042459f350e0ab" name="a712e515b125851e237042459f350e0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712e515b125851e237042459f350e0ab">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>All components are initialized with this value.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> foo({2,3,5,7});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">double</span> some_value = 1.0L;</div>
<div class="line"> </div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#a712e515b125851e237042459f350e0ab">init</a>(some_value);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_a712e515b125851e237042459f350e0ab"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#a712e515b125851e237042459f350e0ab">TensorUtils::TensorBase::init</a></div><div class="ttdeci">void init(const T &amp;val)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac97bc4faf34b9d96682cb2089e8867c3" name="ac97bc4faf34b9d96682cb2089e8867c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97bc4faf34b9d96682cb2089e8867c3">&#9670;&nbsp;</a></span>minus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::minus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_lhs</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_rhs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the difference of a sub-tensor of this tensor with a sub-tensor of <code>rhs</code>. Number of components must match, else <a class="el" href="classTensorUtils_1_1ErrorHandler_1_1ShapeMismatch.html">ErrorHandler::ShapeMismatch</a> is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
    <tr><td class="paramname">at_lhs</td><td>Indices specifying the sub-tensor of the first operand. </td></tr>
    <tr><td class="paramname">at_rhs</td><td>Indices specifying the sub-tensor of the second operand.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar({2*3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> foobar;</div>
<div class="line"> </div>
<div class="line">    foobar = foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#ac97bc4faf34b9d96682cb2089e8867c3">minus</a>(bar, {1,2}, {5}); <span class="comment">// foobar has shape {5,7}</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_ac97bc4faf34b9d96682cb2089e8867c3"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#ac97bc4faf34b9d96682cb2089e8867c3">TensorUtils::TensorBase::minus</a></div><div class="ttdeci">TensorBase&lt; T &gt; minus(TensorBase&lt; T2 &gt; &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={}, const std::vector&lt; size_t &gt; &amp;at_rhs={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3534521430b09a31d662a714cde93614" name="a3534521430b09a31d662a714cde93614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3534521430b09a31d662a714cde93614">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::multiply </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_lhs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiply a sub-tensor of this tensor with <code>rhs</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
    <tr><td class="paramname">at_lhs</td><td>Indices specifying the sub-tensor of the first operand.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#a3534521430b09a31d662a714cde93614">multiply</a>(5, {1,2});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_a3534521430b09a31d662a714cde93614"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#a3534521430b09a31d662a714cde93614">TensorUtils::TensorBase::multiply</a></div><div class="ttdeci">TensorBase&lt; T &gt; &amp; multiply(const T &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5b9f812fee355d67df2e7f5d2b409299" name="a5b9f812fee355d67df2e7f5d2b409299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9f812fee355d67df2e7f5d2b409299">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Access a component or the first component of a sub-tensor. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> elem = 0;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n0=0; n0&lt;foo.shape[0]; n0++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n1=0; n1&lt;foo.shape[1]; n1++)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n2=0; n2&lt;foo.shape[2]; n2++)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n3=0; n3&lt;foo.shape[3]; n3++)</div>
<div class="line">                {</div>
<div class="line">                    foo(n0,n1,n2,n3) = elem;</div>
<div class="line">                    elem++;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Remember that TensorBase&lt;T&gt; inherits from std::vector&lt;T&gt;</span></div>
<div class="line">    elem=0;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> it=foo.begin(); it!=foo.end(); it++)</div>
<div class="line">    {</div>
<div class="line">        *it = elem;</div>
<div class="line">        elem++;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;size_t&gt; index = {1,2,4,6};</div>
<div class="line">    foo(index) = 5.0;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;size_t*&gt; index_ptr = { &amp;index[0],&amp;index[1],&amp;index[2],&amp;index[3] };</div>
<div class="line">    foo(index_ptr) = 5.0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">double</span>* ptr_to_subtensor = &amp;foo({1,2});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab15e6c2ac11c6c84b9ae17f7628b3ce3" name="ab15e6c2ac11c6c84b9ae17f7628b3ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15e6c2ac11c6c84b9ae17f7628b3ce3">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Scalar multiplication from the right. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo = foo*2;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ade9068061b6ccbd3087fee92ac889e57" name="ade9068061b6ccbd3087fee92ac889e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9068061b6ccbd3087fee92ac889e57">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Multiply this tensor with <code>rhs</code>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo *= 2;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aadb39881c875044087940545f62f85f8" name="aadb39881c875044087940545f62f85f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb39881c875044087940545f62f85f8">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the sum of this tensor <code>with</code> rhs. Number of components must match, else <a class="el" href="classTensorUtils_1_1ErrorHandler_1_1ShapeMismatch.html">ErrorHandler::ShapeMismatch</a> is thrown. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo = foo + bar;</div>
<div class="line"> </div>
<div class="line">    bar.<a class="code hl_function" href="classTensorUtils_1_1TensorDerived.html#aebad84a5c4d2433e48b8c8f77603d6df">alloc</a>({2*3,5*7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo = foo + bar;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a10a28b9b40eacef639302f9bccb03b6e" name="a10a28b9b40eacef639302f9bccb03b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a28b9b40eacef639302f9bccb03b6e">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add the tensor <code>rhs</code>. Number of components must match, else <a class="el" href="classTensorUtils_1_1ErrorHandler_1_1ShapeMismatch.html">ErrorHandler::ShapeMismatch</a> is thrown. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo += bar;</div>
<div class="line"> </div>
<div class="line">    bar.<a class="code hl_function" href="classTensorUtils_1_1TensorDerived.html#aebad84a5c4d2433e48b8c8f77603d6df">alloc</a>({2*3,5*7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo += bar;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a670ea0ff13c250e1712c8ee5dd4edadf" name="a670ea0ff13c250e1712c8ee5dd4edadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670ea0ff13c250e1712c8ee5dd4edadf">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the difference of this tensor <code>with</code> rhs. Number of components must match, else <a class="el" href="classTensorUtils_1_1ErrorHandler_1_1ShapeMismatch.html">ErrorHandler::ShapeMismatch</a> is thrown. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo = foo - bar;</div>
<div class="line"> </div>
<div class="line">    bar.<a class="code hl_function" href="classTensorUtils_1_1TensorDerived.html#aebad84a5c4d2433e48b8c8f77603d6df">alloc</a>({2*3,5*7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo = foo - bar;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5a5ff63bddf658da9dae9ce45d57766d" name="a5a5ff63bddf658da9dae9ce45d57766d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5ff63bddf658da9dae9ce45d57766d">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Substract the tensor <code>rhs</code>. Number of components must match, else <a class="el" href="classTensorUtils_1_1ErrorHandler_1_1ShapeMismatch.html">ErrorHandler::ShapeMismatch</a> is thrown. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo -= bar;</div>
<div class="line"> </div>
<div class="line">    bar.<a class="code hl_function" href="classTensorUtils_1_1TensorDerived.html#aebad84a5c4d2433e48b8c8f77603d6df">alloc</a>({2*3,5*7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo -= bar;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aeeb96bbabd1805fac487bfb3ecef075d" name="aeeb96bbabd1805fac487bfb3ecef075d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb96bbabd1805fac487bfb3ecef075d">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Element-wise division. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo = foo/2;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6dd9a48d430299ab6a86dee248490869" name="a6dd9a48d430299ab6a86dee248490869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd9a48d430299ab6a86dee248490869">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Divide this tensor with <code>rhs</code>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo /= 2;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae440fc1ecba5d939aa97f5c06964b712" name="ae440fc1ecba5d939aa97f5c06964b712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae440fc1ecba5d939aa97f5c06964b712">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize this tensor from an array in lexicographical order. No error-handling! </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7});</div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">arange</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">double</span> raw_data[2*3*5*7];</div>
<div class="line">    foo &gt;&gt; raw_data[0]; <span class="comment">// copy data to array</span></div>
<div class="line">    foo &lt;&lt; raw_data[0]; <span class="comment">// initialize from array</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">double</span> multi_array[2][3][5][7];</div>
<div class="line">    foo &gt;&gt; multi_array[0][0][0][0]; <span class="comment">// copy data to multi-dimensional array</span></div>
<div class="line">    foo &lt;&lt; multi_array[0][0][0][0]; <span class="comment">// initialize from multi-dimensional array</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2eed73b66bc0280587bf7b1b06ab3e1a" name="a2eed73b66bc0280587bf7b1b06ab3e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eed73b66bc0280587bf7b1b06ab3e1a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assigns the components in lexicographical order from a vector. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7});</div>
<div class="line"> </div>
<div class="line">    foo = std::vector&lt;long double&gt;(foo.size(), 1.0L); <span class="comment">// initialize from a vector</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a09696fdcb5d7cb23e213418097c6adf1" name="a09696fdcb5d7cb23e213418097c6adf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09696fdcb5d7cb23e213418097c6adf1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assigns this tensor with <code>rhs</code>. If the components have the same type, the default copy assignment is invoked. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar;</div>
<div class="line"> </div>
<div class="line">    bar = foo;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af7965f2a99720460c6d7193b84145c8f" name="af7965f2a99720460c6d7193b84145c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7965f2a99720460c6d7193b84145c8f">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T2 &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copy the components in lexicographical order to an array. No error-handling! </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7});</div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">arange</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">double</span> raw_data[2*3*5*7];</div>
<div class="line">    foo &gt;&gt; raw_data[0]; <span class="comment">// copy data to array</span></div>
<div class="line">    foo &lt;&lt; raw_data[0]; <span class="comment">// initialize from array</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">double</span> multi_array[2][3][5][7];</div>
<div class="line">    foo &gt;&gt; multi_array[0][0][0][0]; <span class="comment">// copy data to multi-dimensional array</span></div>
<div class="line">    foo &lt;&lt; multi_array[0][0][0][0]; <span class="comment">// initialize from multi-dimensional array</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9969230537671dbb1390c535926da127" name="a9969230537671dbb1390c535926da127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9969230537671dbb1390c535926da127">&#9670;&nbsp;</a></span>plus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_lhs</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_rhs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the sum of a sub-tensor of this tensor with a sub-tensor of <code>rhs</code>. Number of components must match, else <a class="el" href="classTensorUtils_1_1ErrorHandler_1_1ShapeMismatch.html">ErrorHandler::ShapeMismatch</a> is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
    <tr><td class="paramname">at_lhs</td><td>Indices specifying the sub-tensor of the first operand. </td></tr>
    <tr><td class="paramname">at_rhs</td><td>Indices specifying the sub-tensor of the second operand.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar({2*3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> foobar;</div>
<div class="line"> </div>
<div class="line">    foobar = foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#a9969230537671dbb1390c535926da127">plus</a>(bar, {1,2}, {5}); <span class="comment">// foobar has shape {5,7}</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_a9969230537671dbb1390c535926da127"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#a9969230537671dbb1390c535926da127">TensorUtils::TensorBase::plus</a></div><div class="ttdeci">TensorBase&lt; T &gt; plus(TensorBase&lt; T2 &gt; &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={}, const std::vector&lt; size_t &gt; &amp;at_rhs={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af745ceedbb4628bae6cc467b250f67b0" name="af745ceedbb4628bae6cc467b250f67b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af745ceedbb4628bae6cc467b250f67b0">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prints all sub-matrices in lexicographical order to "std::cout". Vectors are printed as row-vectors. The format is the same as for <a class="el" href="classTensorUtils_1_1TensorBase.html#a8a701c44e4f0a077a7c2c45d43d88571">write</a>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> foo({2,3,5,7});</div>
<div class="line"> </div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">arange</a>();</div>
<div class="line"> </div>
<div class="line">    foo.print();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a73a7d5fdbd5851469350127a3d2e7213" name="a73a7d5fdbd5851469350127a3d2e7213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a7d5fdbd5851469350127a3d2e7213">&#9670;&nbsp;</a></span>product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::product </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_lhs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the product of a sub-tensor of this tensor with <code>rhs</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
    <tr><td class="paramname">at_lhs</td><td>Indices specifying the sub-tensor of the first operand.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar;</div>
<div class="line"> </div>
<div class="line">    bar = foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#a73a7d5fdbd5851469350127a3d2e7213">product</a>(5, {1,2}); <span class="comment">// bar has shape {5,7}</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_a73a7d5fdbd5851469350127a3d2e7213"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#a73a7d5fdbd5851469350127a3d2e7213">TensorUtils::TensorBase::product</a></div><div class="ttdeci">TensorBase&lt; T &gt; product(const T &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a91e417f700ec1f412fd004ea510a5e3a" name="a91e417f700ec1f412fd004ea510a5e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e417f700ec1f412fd004ea510a5e3a">&#9670;&nbsp;</a></span>quotient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::quotient </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_lhs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the quotient of a sub-tensor of this tensor with <code>rhs</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
    <tr><td class="paramname">at_lhs</td><td>Indices specifying the sub-tensor of the first operand.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar;</div>
<div class="line"> </div>
<div class="line">    bar = foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#a91e417f700ec1f412fd004ea510a5e3a">quotient</a>(5, {1,2}); <span class="comment">// bar has shape {5,7}</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_a91e417f700ec1f412fd004ea510a5e3a"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#a91e417f700ec1f412fd004ea510a5e3a">TensorUtils::TensorBase::quotient</a></div><div class="ttdeci">TensorBase&lt; T &gt; quotient(const T &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5e4589420d9febe0a07051d9358567c5" name="a5e4589420d9febe0a07051d9358567c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4589420d9febe0a07051d9358567c5">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads arbitrary tensors from text or binary files. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Specifies the source path. The extension specifies the file format. For text files use any extension except the following that are used for binary files:<ul>
<li>.f32 float</li>
<li>.f64 double</li>
<li>.f80 long double</li>
<li>.uc unsigned char</li>
<li>.sc signed char</li>
<li>.us unsigned short</li>
<li>.s short</li>
<li>.u unsigned</li>
<li>.int int</li>
<li>.ul unsigned long</li>
<li>.l long</li>
<li>.ull unsigned long long</li>
<li>.ll long long</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>For text files, the first line must contain the shape of the tensor. Empty lines are ignored. The header line is followed by a lexicographical list of all sub-matrices. Vectors are row-vectors. Note that <a class="el" href="classTensorUtils_1_1TensorBase.html#af745ceedbb4628bae6cc467b250f67b0">print</a> will display the same format.</p>
<p >Binary files are formatted as follows. The first block contains sizeof(size_t) bytes specifying shape.size(). The second block contains shape.size()*sizeof(size_t) bytes specifying the components of <a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a>. The third block contains sizeof(size_t) bytes specifying the container size. The fourth block contains this-&gt;size()*sizeof(T) bytes specifying the components of the tensor, where T is the type of the components specified by the extension. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>TensorUtils;</div>
<div class="line">    <span class="keyword">using namespace </span>ErrorHandler;</div>
<div class="line"> </div>
<div class="line">    tensor&lt;double&gt; foo;</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        foo.read(<span class="stringliteral">&quot;foo.txt&quot;</span>);</div>
<div class="line">        foo.read(<span class="stringliteral">&quot;foo.f32&quot;</span>);</div>
<div class="line">        foo.read(<span class="stringliteral">&quot;foo.ull&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(UnableToOpenFile &amp;ex) <span class="comment">// unable to open file</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(ShapeMismatch &amp;ex) <span class="comment">// Shape in header does not match given data: corrupted file?</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(std::exception &amp;ex) <span class="comment">// catch any other exception</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a474772c9878ca9498b7caf39204f8454" name="a474772c9878ca9498b7caf39204f8454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474772c9878ca9498b7caf39204f8454">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assigns a new <a class="el" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a> to this tensor and updates <a class="el" href="classTensorUtils_1_1TensorBase.html#a10cdd295089539c15f9b09726a9371a0">incr</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>Specifies the new shape.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> foo({2,3,5,7});</div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">arange</a>();</div>
<div class="line"> </div>
<div class="line">    foo.reshape({2*3,5*7}); <span class="comment">// same components with same order, but different shape</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3728b9a49d84b535815d4b7335132f29" name="a3728b9a49d84b535815d4b7335132f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3728b9a49d84b535815d4b7335132f29">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx_at</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Slices a sub-tensor and returns by value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx_at</td><td>Permutation of (0,1,...,N-1), where N is the rank. Indices are transposed accordingly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a the sub-tensor addressed by <code>idx_at</code> by value.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> foo({2,3,5,7});</div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">arange</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> bar;</div>
<div class="line">    bar = foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#a3728b9a49d84b535815d4b7335132f29">slice</a>({1,2}); <span class="comment">// contains the last sub-tensor with shape {5,7}</span></div>
<div class="line"> </div>
<div class="line">    bar.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#af745ceedbb4628bae6cc467b250f67b0">print</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_a3728b9a49d84b535815d4b7335132f29"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#a3728b9a49d84b535815d4b7335132f29">TensorUtils::TensorBase::slice</a></div><div class="ttdeci">TensorBase&lt; T &gt; slice(const std::vector&lt; size_t &gt; &amp;idx_at)</div></div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_af745ceedbb4628bae6cc467b250f67b0"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#af745ceedbb4628bae6cc467b250f67b0">TensorUtils::TensorBase::print</a></div><div class="ttdeci">void print()</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abf02bbd67b6ae85949f261e149076028" name="abf02bbd67b6ae85949f261e149076028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf02bbd67b6ae85949f261e149076028">&#9670;&nbsp;</a></span>substract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; &amp; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::substract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_lhs</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>at_rhs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Substract a sub-tensor of <code>rhs</code> from a sub-tensor of this tensor. Number of components must match, else <a class="el" href="classTensorUtils_1_1ErrorHandler_1_1ShapeMismatch.html">ErrorHandler::ShapeMismatch</a> is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
    <tr><td class="paramname">at_lhs</td><td>Indices specifying the sub-tensor of the first operand. </td></tr>
    <tr><td class="paramname">at_rhs</td><td>Indices specifying the sub-tensor of the second operand.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;float&gt;</a> bar({2*3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#abf02bbd67b6ae85949f261e149076028">substract</a>(bar, {1,2}, {5});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_abf02bbd67b6ae85949f261e149076028"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#abf02bbd67b6ae85949f261e149076028">TensorUtils::TensorBase::substract</a></div><div class="ttdeci">TensorBase&lt; T &gt; &amp; substract(TensorBase&lt; T2 &gt; &amp;rhs, const std::vector&lt; size_t &gt; &amp;at_lhs={}, const std::vector&lt; size_t &gt; &amp;at_rhs={})</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab6b60930e74e3e4780e4f06c4e30f5de" name="ab6b60930e74e3e4780e4f06c4e30f5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b60930e74e3e4780e4f06c4e30f5de">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>axes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Permutes the indices of the tensor and returns by value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>Permutation of (0,1,...,N-1), where N is the rank. Indices are transposed accordingly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tensor with transposed indices.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> foo({2,3,5,7});</div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">arange</a>();</div>
<div class="line">    foo = foo.transpose({0,2,1,3}); <span class="comment">// New shape is: {2,5,3,7}</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8a701c44e4f0a077a7c2c45d43d88571" name="a8a701c44e4f0a077a7c2c45d43d88571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a701c44e4f0a077a7c2c45d43d88571">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>oname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write arbitrary tensors to text or binary files. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oname</td><td>Specifies the file name. The extension specifies the file format. For text files use any extension except the following that are used for binary files:<ul>
<li>.f32 float</li>
<li>.f64 double</li>
<li>.f80 long double</li>
<li>.uc unsigned char</li>
<li>.sc signed char</li>
<li>.us unsigned short</li>
<li>.s short</li>
<li>.u unsigned</li>
<li>.int int</li>
<li>.ul unsigned long</li>
<li>.l long</li>
<li>.ull unsigned long long</li>
<li>.ll long long </li>
</ul>
</td></tr>
    <tr><td class="paramname">folder</td><td>Specifies the output path.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="classTensorUtils_1_1TensorBase.html#a5e4589420d9febe0a07051d9358567c5">read</a> for details on the file format. You may add the number of significant digits when writing text files, see <a class="el" href="classTensorUtils_1_1TensorBase.html#ae877870922e2b9e60fc866a855da42be">write(std::string,std::string,int)</a>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>TensorUtils;</div>
<div class="line"> </div>
<div class="line">    tensor&lt;double&gt; foo({2,3,5,7}, 1.0);</div>
<div class="line"> </div>
<div class="line">    foo.write(<span class="stringliteral">&quot;foo.txt&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, 10);  <span class="comment">// text file: writes 10 significant digits</span></div>
<div class="line"> </div>
<div class="line">    foo.write(<span class="stringliteral">&quot;foo.dat&quot;</span>, <span class="stringliteral">&quot;./&quot;</span>); <span class="comment">// text file: if floating point: uses std::numeric_limits&lt;T&gt;::max_digits10</span></div>
<div class="line"> </div>
<div class="line">    foo.write(<span class="stringliteral">&quot;foo.f32&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>);  <span class="comment">// binary file: float</span></div>
<div class="line">    foo.write(<span class="stringliteral">&quot;foo.ull&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>);  <span class="comment">// binary file: unsigned long long</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae877870922e2b9e60fc866a855da42be" name="ae877870922e2b9e60fc866a855da42be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae877870922e2b9e60fc866a855da42be">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>oname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>folder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >For text files only. See also <a class="el" href="classTensorUtils_1_1TensorBase.html#a8a701c44e4f0a077a7c2c45d43d88571">write(std::string,std::string)</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oname</td><td>Specifies the file name. </td></tr>
    <tr><td class="paramname">folder</td><td>Specifies the output path. </td></tr>
    <tr><td class="paramname">precision</td><td>Number of significant digits when writing text files for floating point types.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>TensorUtils;</div>
<div class="line"> </div>
<div class="line">    tensor&lt;double&gt; foo({2,3,5,7}, 1.0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        foo.write(<span class="stringliteral">&quot;foo.txt&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, 10); <span class="comment">// OK!</span></div>
<div class="line">        foo.write(<span class="stringliteral">&quot;foo.f32&quot;</span>, <span class="stringliteral">&quot;.&quot;</span>, 10); <span class="comment">// throws an error!</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(std::runtime_error &amp;ex) <span class="comment">// Binary file extension but text file requested!</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a309bb54047ba27387bb12b5a95e31e9e" name="a309bb54047ba27387bb12b5a95e31e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309bb54047ba27387bb12b5a95e31e9e">&#9670;&nbsp;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTensorUtils_1_1TensorBase.html">TensorBase</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Scalar multiplication from the left. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;long double&gt;</a> foo({2,3,5,7},1.0);</div>
<div class="line"> </div>
<div class="line">    foo = 2*foo;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a10cdd295089539c15f9b09726a9371a0" name="a10cdd295089539c15f9b09726a9371a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cdd295089539c15f9b09726a9371a0">&#9670;&nbsp;</a></span>incr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::incr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Internally accelerates access of components. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> foo({10,10,10});</div>
<div class="line">    foo.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">arange</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> i_am_true = foo(2,3,5) == foo[2*foo.incr[0]+3*foo.incr[1]+5*foo.incr[2]];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adb62602f86f3266f2344c69b15b1fe28" name="adb62602f86f3266f2344c69b15b1fe28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb62602f86f3266f2344c69b15b1fe28">&#9670;&nbsp;</a></span>shape</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; <a class="el" href="classTensorUtils_1_1TensorBase.html">TensorUtils::TensorBase</a>&lt; T &gt;::shape</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Storage for all components in lexicographical order. The initialized memory will be exactly the same as for multidimensional arrays. See also <a class="el" href="classTensorUtils_1_1TensorBase.html#ae440fc1ecba5d939aa97f5c06964b712">operator&lt;&lt;</a> and <a class="el" href="classTensorUtils_1_1TensorBase.html#af7965f2a99720460c6d7193b84145c8f">operator&gt;&gt;</a>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> my_tensor({10,10});</div>
<div class="line"> </div>
<div class="line">    my_tensor.<a class="code hl_function" href="classTensorUtils_1_1TensorBase.html#ab0349fb0faae387b46f42a8ab4f4373a">arange</a>(1); <span class="comment">// same as the following</span></div>
<div class="line"> </div>
<div class="line">    my_tensor[0]=1;</div>
<div class="line">    my_tensor[1]=2;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    my_tensor[99]=100;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Specifies the range for all indices. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;TensorUtils.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classTensorUtils_1_1TensorDerived.html">TensorUtils::tensor&lt;double&gt;</a> foo({2,3});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> i_am_true = foo.<a class="code hl_variable" href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">shape</a> == std::vector&lt;size_t&gt;{2,3} ;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;foo.shape[0]; i++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0; j&lt;foo.shape[1]; j++)</div>
<div class="line">        {</div>
<div class="line">            foo(i,j);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTensorUtils_1_1TensorBase_html_adb62602f86f3266f2344c69b15b1fe28"><div class="ttname"><a href="classTensorUtils_1_1TensorBase.html#adb62602f86f3266f2344c69b15b1fe28">TensorUtils::TensorBase::shape</a></div><div class="ttdeci">std::vector&lt; size_t &gt; shape</div><div class="ttdef"><b>Definition:</b> TensorBase.hpp:1101</div></div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="TensorBase_8hpp_source.html">TensorBase.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
